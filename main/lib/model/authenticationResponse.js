"use strict";

const Model = require('./model');

/**
 *
 * @constructor
 */
function AuthenticationResponse(data) {
    Model.call(this);

    if (!data || !data.redirectUri || !data.responseType) {
        throw new Error("Illegal Argument!");
    } 
    this.state = null;
    this.scope = null;
    this.code = null;
    this.redirectUri = null;
    this.tokenType = data.tokenType || 'bearer';
    this.idToken = null;
    this.accessToken = null;
    this.expiresIn = null;
    this.responseType = null;

    this.init(data);
}

AuthenticationResponse.prototype = Object.create(Model.prototype);
AuthenticationResponse.prototype.constructor = AuthenticationResponse;

/**
 *
 * For code grant:
 *  code - REQUIRED. The authorization code generated by the authorization server. The authorization code MUST expire
 *                   shortly after it is issued to mitigate the risk of leaks. A maximum authorization code
 *                   lifetime of 10 minutes is RECOMMENDED. The client MUST NOT use the authorization code more than
 *                   once. If an authorization code is used more than once, the authorization server MUST deny the
 *                   request and SHOULD revoke (when possible) all tokens previously issued based on that
 *                   authorization code. The authorization code is bound to the client identifier and redirection URI.
 *  state - REQUIRED if the "state" parameter was present in the client authorization request. The exact value
 *                   received from the client.
 *
 * For implicit grant:
 *
 * access_token OAuth 2.0 Access Token. This is returned unless the response_type value used is id_token.
 * token_type   OAuth 2.0 Token Type value. The value MUST be Bearer or another token_type value that the
 *              Client has negotiated with the Authorization Server. Clients implementing this profile MUST
 *              support the OAuth 2.0 Bearer Token Usage [RFC6750] specification. This profile only describes
 *              the use of bearer tokens. This is returned in the same cases as access_token is.
 * id_token REQUIRED. ID Token.
 * state OAuth 2.0 state value. REQUIRED if the state parameter is present in the Authorization Request.
 *                 Clients MUST verify that the state value is equal to the value of state parameter in the
 *                 Authorization Request.
 * expires_in  OPTIONAL. Expiration time of the Access Token in seconds since the response was generated.
 *
 * @returns {string} - the redirect url with the corresponding parameters.
 */
AuthenticationResponse.prototype.toUri = function() {
    let uri = this.redirectUri;
    if (this.responseType === 'code') {
        uri += '?code=' + encodeURIComponent(this.code);
        uri += this._commonPart();
    } else if (this.isImplicitGrantSync()) {

        uri += '?token_type=' + encodeURIComponent(this.tokenType);
        if (this.responseType === 'id_token token' || this.responseType === 'token') {

            if (!this.accessToken) {
                throw new Error('The access token is not defined but required!');
            }

            uri += '&access_token=' + encodeURIComponent(this.accessToken);
        }

        if (this.responseType === 'id_token token' || this.responseType === 'id_token') {
            if (!this.idToken) {
                throw new Error('The id token is not defined but required!');
            }
            uri += '&id_token=' + encodeURIComponent(this.idToken);
        }

        if (this.expiresIn) {
            uri += '&expires_in=' + encodeURIComponent(this.expiresIn);
        }
        uri += this._commonPart();

    }

    return uri;
};

/**
 *
 * @returns {boolean}
 */
AuthenticationResponse.prototype.isImplicitGrantSync = function () {
    return this.responseType === 'id_token token' || this.responseType === 'id_token' || this.responseType === 'token';
};

/**
 *
 * @returns {string}
 * @private
 */
AuthenticationResponse.prototype._commonPart = function() {
    let uri = '';
    if (this.state) {
        uri += '&state=' + encodeURIComponent(this.state);
    }

    if (this.scope) {
        uri += '&scope=' + encodeURIComponent(this.scope);
    }

    return uri;
};



module.exports = AuthenticationResponse;